---
auth: 
---
#动态规划、记搜、回溯笔记
记录一下动态规划、记搜、回溯强化练习的收获。

## 一些认识和方法论
先总结一些相对抽象的、顶层的认识、概念、方法论。
### 自底向上和自顶向下的动态规划
这两种动态规划最直观的区别在于，自底向上考虑的是当前状态可以由哪些之前的状态转移得到，自顶向下考虑的是当前状态可以推出哪些之后的状态。个人感觉自顶向下的状态转移其实更符合直觉。
自底向上的动态规划的代码形式往往是基于循环的狭义动态规划。需要额外考虑的是base case，也就是根据循环中状态转移的方向确定初始化条件。自底向上的动态规划考虑当前状态可以由哪些之前的状态转移得到，因此需要初始化的是最初的状态。
自顶向下的动态规划的代码形式往往是基于递归的记搜。由于自顶向下的动态规划考虑可以推出哪些之后的状态，因此需要额外考虑的是递归结束的边界条件。如果边界条件考虑错误则可能导致结果错误甚至无限递归爆栈。
通常情况上述两种动态规划可以相互转化，两种写法理论上时间复杂度是基本一致的。

### 暴力搜索和动态规划
通常的暴力搜索指无缓存的回溯，动态规划指包括记搜和动态规划两种方法的线性遍历。暴力搜索假设每一层可能的分支有n个，共m层，则时间复杂度为$O(n^m)$ 。而记搜和动态规划的时间复杂度视问题类型而定，通常不会超过$O(n^2)$。但并非动态规划的时间复杂度就一定比暴力搜索好，尤其是背包类型的问题，动态规划的时间复杂度还需要考虑背包的维度和规模。如果背包维度超过一维且规模很大，而物品数量较少（小几十），则可以考虑暴力搜索。
通常测评机的时间复杂度敏感阈值在1e8左右，对于2分支的暴力搜索大概在$2^{26}$到$2^{27}$之间。

## 需要注意的问题
在练习中遇到的问题和犯的错

### 不可以将状态列在dp数组之外单独记
当出现这个想法的时候，就要考虑是不是dp数组的维度开少了。dp数组的定义需要考虑问题问什么和有哪些条件和状态影响某一个子问题的结果。

## 典型例题
针对上述内容的几道例题。
### 项目规划

H公司在做项目规划，当前3个团队(前端、后端、测试)共同规划完成M个项目，这时候给你3个团队各自人力总和值(XXX人月)。对于某个项目，项目都需要多个团队共同投入完成，每个项目会有一个预估的价值(XXX万元)，同时一个项目都需要多个团队共同投入完成(每个项目会有对三个团队的人力需求数量)。让你在多个项目中做项目规划，在人力允许的范围内，使得能够承接的所有项目的预估价值总和最大。
备注:返回结果为能够承接的最大预估价值。如果人力无法承接任何项目,返回0;
**解答要求**
时间限制:C/C++ 1000ms,其他语言:2000ms内存限制:C/C++ 256MB.其他语言:512MB
**输入**
项目个数:m (0<m<= 20);
三个团队人力总和:S1,S2,S3 (0<Si <= 1000)
每个项目预估价值:V1,V2. V3, ... Vn; (O<M<=1000000)
每个项目所需人力:{ P11,P12, P13),(P21, P22,P23 )1. {P31, P32,P33.., (Pm1,Pm2, Pm3);(0<= Pxy <= 1000)
**输出**
最大价值:MaxValue
**样例1**
**输入**:2
100 100 100
10000 8000
60 60 60
60 60 60
**输出**:10000
**解释:**
2:2个项目
100 100 100:三个团队各自的人力总和
10000,8000:项目的预估价值(1个项目一个输入,多个项目会有多个输入)
60 60 60:第一个项目对于三个团队的人力需求
60 60 60:第二个项目对于三个团队的人力需求
10000:输出项目规划的结果



思路：

```
本题从逻辑上看很像01背包，但需要注意的是背包有3个维度，每个维度容量都是1e3，按照01背包去遍历则总时间复杂度达到1e9，超时。
而项目数量规模仅为20，暴力回溯时间复杂度2^20约为1e6，不会超时。
每个项目选择做或不做，取最大值。
```

代码

```C++
int dfs(int idx, int s1, int s2, int s3, vector<int>& value, vector<vector<int>>& p){
    if(idx == value.size()) return 0;
    int ans = 0;
    if(p[idx][0] <= s1 && p[idx][1] <= s2 && p[idx][2] <= s3){
        int yes = dfs(idx + 1, s1 - p[idx][0], s2 - p[idx][1], s3 - p[idx][2], value, p) + value[idx];
        int no = dfs(idx + 1, s1, s2, s3, value, p);
        ans = max(yes, no);
    }
    else{
        ans = dfs(idx + 1, s1, s2, s3, value, p);
    }
    return ans;
}

int solution(int m, int s1, int s2, int s3, vector<int>& value, vector<vector<int>>& p){
    vector<int> dp(m, -1);
    return dfs(0, s1, s2, s3, value, p);
}
```

### 新员工考试

小聪入职新公司,参加线上的新员工必备考试,考试共25题，依次是10个判断题(每题2分)、10个单选题(每题4分)和5个多选题(每题8分)，总分100分。
考题只能顺序作答,答对题目获得相应的分数，答错题目获得0分,考试系统不提示作答是否正确，答题过程中如果累积有3题答错,直接中止考试并计算考试分数。
小聪考试结果是N分(0<=N<=100)，请根据小聪的分数,算出所有可能的答题情况的个数。
解答要求
时间限制: CIC1000ms,其他语言:2000ms
内存限制: C/C256MB,其他语言:512MB
**输入**
整数,表示小聪的考试得分N,N为偶数0<=N<=100(N不会是不可能考出来的分数)。
**输出**
整数表示所有可能的答题情况的个数
**样例1**
**输入:**94
**输出:**100
**解释:**有1道判断题和1道单选题答错,其余的题都答对,所有可能的答题情况的个数为100,
**样例2**
**输入:**100输出:1
**解程:**所有题目全部答对,答题情况的个数为1.



思路：

```
状态有三个维度：做到第几题、得了多少分、错了几道。定义dp[i][j][k]为做了前i道题，得了j分，错了k道有多少种组合。
状态转移：dp[i][j][k] = dp[i - 1][j][k - 1] + dp[i - 1][j - point[i - 1]][k]，即当前题目做错+做对的组合数相加。
由于状态转移中三个维度都依赖前若干项，因此需要初始化三个维度为0的平面。
首先dp[0][0][0] = 1，然后初始化k = 0即做一道对一道的情况，还要初始化做一道错一道(由题意知仅限前三道)。
最终结果为dp[i][n][k]遍历i和k，即固定得分为n的所有情况之和。
```

代码

```C++
int solution1(int n){
    vector<int> point(25);
    for(int i = 0; i < 25; ++i){
        if(i < 10) point[i] = 2;
        else if(i >= 10 && i < 20) point[i] = 4;
        else point[i] = 8;
    }
    vector<vector<vector<int>>> dp(26, vector<vector<int>>(101, vector<int>(4)));
    dp[0][0][0] = 1;
    int sum = 0;
    for(int i = 1; i <= 25; ++i){
        sum += point[i - 1];
        dp[i][sum][0] = 1;
    }
    dp[1][0][1] = 1, dp[2][0][2] = 1, dp[3][0][3] = 1;
    for(int i = 1; i <= 25; ++i){
        for(int j = point[i - 1]; j <= n; ++j){
            for(int k = 1; k < 3; ++k){
                dp[i][j][k] = dp[i - 1][j][k - 1] + dp[i - 1][j - point[i - 1]][k];
            }
        }
    }
    int ans = 0;
    for(int i = 1; i <= 25; ++i){
        for(int k = 0; k <= 3; ++k) ans += dp[i][n][k];
    }
    return ans;
}
```

### 游游购物

游游正在逛超市，有n个商品摆成一排，第i个商品的价格为 ai ,，游游对它的喜爱度为bi。所有商品的价格都是偶数。

超市开展了一个活动，当游游花费原价买了一件商品时，她可以用半价买下一件右边相邻的商品(也可以用原价购买，这样该商品右边的商品就有一次享受半价的机会)。但如果游游半价购买了一件商品,那么下一件右边相邻的商品只能原价购买。

换言之，如果游游想要半价买某一件商品,必须先用原价买下它相邻的左边的那个商品。

游游初初始的钱为x，她想要买的商品的喜爱度总和尽可能大，但总价格不能超过x。你能帮帮她计算最大的喜爱度总和吗?

**输入描述**

第一行输入两个正整数n和x，分别代表商品的数量，以及游游初始的金额数。

第二行输入n个正整数ai，分别代表每个商品的价格。

第三行输入n个正整数bi，分别代表每个商品可以给游游带来的喜爱度。

1<=n, x, ai <= 1000

1 <= bi <= 10^9

保证所有的ai都是偶数。

**输出描述**

一个整数，代表最终喜爱度之和的最大值。



**示例1**

**输入**

4 7

2 2 6 2

3 4 5 1

**输出**

12

**说明**

第一个使用原价卖，第二个物品使用原价买，第三个物品使用半价买，不买第四个物品，这样是最优的。

请注意，如果第二个物品使用了半价，那么第三个物品则不能使用半价。



思路：

```
01背包变种。定义dp[i][j][k]为前n种物品、有j元钱、能半价也能全价（0）或只能全价（1）的最高满意度。
每个物品的k可以为0或1。若当前物品k为0，即当前物品可以半价买，则前一个物品必然是全价买，那么上一个物品的k可以为0或1。
若当前物品k为0，即当前物品必须全价买，则前一个物品的k必然为0
当钱足够全价购买当前物品，可以选择不买、全价买、半价买，取三者最大值。
当钱只够半价买，可以选择不买、半价买，取两者最大值。
当钱不够半价买，则只能不买。
考虑base case为第一个物品，因为第一个物品没有前一个物品可供参考确定半价还是全价。
```
代码

```C++
ll solution1(int n, int x, vector<int>& price, vector<int>& like){
    vector<vector<vector<int>>> dp(n + 1, vector<vector<int>>(x + 1, vector<int>(2)));
    for(int j = price[0]; j <= x; ++j){
        dp[1][j][1] = like[0];
    }
    for(int i = 2; i <= n; ++i){
        for(int j = 0; j <= x; ++j){
            if(j >= price[i - 1]){
                dp[i][j][0] = max({dp[i - 1][j][0], dp[i - 1][j][1], dp[i - 1][j - price[i - 1]][0] + like[i - 1], dp[i - 1][j - price[i - 1]][1] + like[i - 1], dp[i - 1][j - price[i - 1] / 2][0] + like[i - 1]});
                dp[i][j][1] = max({dp[i - 1][j][0], dp[i - 1][j - price[i - 1]][0] + like[i - 1]});
            }
            else if(j >= price[i - 1] / 2 && j < price[i - 1]){
                dp[i][j][0] = max({dp[i - 1][j][0], dp[i - 1][j][1], dp[i - 1][j - price[i - 1] / 2][1] + like[i - 1], dp[i - 1][j - price[i - 1] / 2][0] + like[i - 1]});
                dp[i][j][1] = dp[i - 1][j][0];
            }
            else{
                dp[i][j][0] = max(dp[i - 1][j][0], dp[i - 1][j][1]);
                dp[i][j][1] = dp[i - 1][j][0];
            }
        }
    }
    int ans = 0;
    for(int i = 1; i <= n; ++i){
        int this_max = max(dp[i][x][0], dp[i][x][1]);
        ans = max(ans, this_max);
    }
    return ans;
}
```

## 总结
动态规划这类题切忌用“感觉”做题，必须要将状态转移的维度、条件分析清楚，必要的状态转移维度必须作为dp数组的维度，而不可以单独记录。
确定做题思路之前必须注意数据规模，大致估算这个方法是否会超过1e8这个阈值。